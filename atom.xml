<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AeroReyna</title>
  
  <subtitle>Adolfo E. Reyna-Orta</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-19T00:14:31.490Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Adolfo Reyna-Orta</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Using DOI tags as References with Pandoc</title>
    <link href="http://yoursite.com/2019/07/01/Pandoc-doi2bib-filter/"/>
    <id>http://yoursite.com/2019/07/01/Pandoc-doi2bib-filter/</id>
    <published>2019-07-01T17:35:49.000Z</published>
    <updated>2019-07-19T00:14:31.490Z</updated>
    
    <content type="html"><![CDATA[<p>Pandoc is a powerful text conversion tool that allows to write scientific documents completely in Markdown, and to be transform in properly formatted pdfs, web document, Latex or even Docx files. With the use of filters, pandoc is able to extend the Markdown capabilities to reference in text previously published works, and to make use of figure, equations, table, etc. numbering and inside references as well.</p><p>I personally have found two filters very useful: Pandoc-citeproc and Pandoc-crossref. Citeproc is a filter that looks for references in the text with the form @referencetag and format them with the indicated style (like APA or IEEE) in text and in the reference block at the end of the document. In the other hand, the crossref filter give us a proper way of inserting equations, figures, tables and listings (code blocks), in such ways that they're automatically and properly numbered and referenced through custom tags.</p><p>Pandoc-citeproc requires to be pointed to a biblatex<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> file which contains the information of the works cited, and optionally a csl file that determines the reference style used. These both can be indicated directly in the Markdown file using the YAML block in the beginning of the document as follows:</p><pre class="markdonw"><code>paper.md---title: Pandoc doi2bib filterbibliography: library.bibcsl: csl/apa.csl---The author of [@Fausto2019] has mentioned this issue before.# Refereces:</code></pre><p>and the .bib file should contain the information of the reference such as:</p><pre class="biblatex"><code>@article{@Fausto2019,    doi = {10.1007/s10462-018-09676-2},    url = {https://doi.org/10.1007%2Fs10462-018-09676-2},    year = 2019,    month = {jan},    publisher = {Springer Nature},    author = {Fernando Fausto and Adolfo Reyna-Orta and Erik Cuevas and {\&#39;{A}}ngel G. Andrade and Marco Perez-Cisneros},    title = {From ants to whales: metaheuristics for all tastes},    journal = {Artificial Intelligence Review}}</code></pre><p>Then the command <code>pandoc -s paper.md --filter pandoc-citeproc -t html</code> return the converted text from markdown to html with the references included:</p><div class="sourceCode" id="cb3"><pre class="sourceCode html"><code class="sourceCode html"><span id="cb3-1"><a href="#cb3-1"></a><span class="co">&lt;!--Partial Result:--&gt;</span></span><span id="cb3-2"><a href="#cb3-2"></a><span class="kw">&lt;body&gt;</span></span><span id="cb3-3"><a href="#cb3-3"></a><span class="kw">&lt;header</span><span class="ot"> id=</span><span class="st">&quot;title-block-header&quot;</span><span class="kw">&gt;</span></span><span id="cb3-4"><a href="#cb3-4"></a><span class="kw">&lt;h1</span><span class="ot"> class=</span><span class="st">&quot;title&quot;</span><span class="kw">&gt;</span>Pandoc doi2bib filter<span class="kw">&lt;/h1&gt;</span></span><span id="cb3-5"><a href="#cb3-5"></a><span class="kw">&lt;p</span><span class="ot"> class=</span><span class="st">&quot;date&quot;</span><span class="kw">&gt;</span>2019-07-01 10:35:49<span class="kw">&lt;/p&gt;</span></span><span id="cb3-6"><a href="#cb3-6"></a><span class="kw">&lt;/header&gt;</span></span><span id="cb3-7"><a href="#cb3-7"></a><span class="kw">&lt;p&gt;</span>The author of <span class="kw">&lt;span</span><span class="ot"> class=</span><span class="st">&quot;citation&quot;</span><span class="ot"> data-cites=</span><span class="st">&quot;Fausto2019&quot;</span><span class="kw">&gt;</span>(Fausto et al. 2019)<span class="kw">&lt;/span&gt;</span> has mentioned this issue before.<span class="kw">&lt;/p&gt;</span></span><span id="cb3-8"><a href="#cb3-8"></a><span class="kw">&lt;h1</span><span class="ot"> id=</span><span class="st">&quot;refereces&quot;</span><span class="ot"> class=</span><span class="st">&quot;unnumbered&quot;</span><span class="kw">&gt;</span>Refereces:<span class="kw">&lt;/h1&gt;</span></span><span id="cb3-9"><a href="#cb3-9"></a><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;refs&quot;</span><span class="ot"> class=</span><span class="st">&quot;references&quot;</span><span class="ot"> role=</span><span class="st">&quot;doc-bibliography&quot;</span><span class="kw">&gt;</span></span><span id="cb3-10"><a href="#cb3-10"></a><span class="kw">&lt;div</span><span class="ot"> id=</span><span class="st">&quot;ref-Fausto2019&quot;</span><span class="kw">&gt;</span></span><span id="cb3-11"><a href="#cb3-11"></a><span class="kw">&lt;p&gt;</span>Fausto, Fernando, Adolfo Reyna-Orta, Erik Cuevas, Ángel G. Andrade, and Marco Perez-Cisneros. 2019. ÔÇ£From Ants to Whales: Metaheuristics for All Tastes.ÔÇØ <span class="kw">&lt;em&gt;</span>Artificial Intelligence Review<span class="kw">&lt;/em&gt;</span>, January. Springer Nature. <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;https://doi.org/10.1007/s10462-018-09676-2&quot;</span><span class="kw">&gt;</span>https://doi.org/10.1007/s10462-018-09676-2<span class="kw">&lt;/a&gt;</span>.<span class="kw">&lt;/p&gt;</span></span><span id="cb3-12"><a href="#cb3-12"></a><span class="kw">&lt;/div&gt;</span></span><span id="cb3-13"><a href="#cb3-13"></a><span class="kw">&lt;/div&gt;</span></span><span id="cb3-14"><a href="#cb3-14"></a><span class="kw">&lt;/body&gt;</span></span></code></pre></div><p>In this way, it is fairly simple to write and manage the document and presented in the required format for collages to collaborate or to be submitted for publication (most likely in Latex).</p><p>However, with this framework the creation and maintaining of the references file (.bib) and the referring tags of the cited works is left to be done manually or by third parties, such as reference managers like Zotero or Mendeley.</p><p>Due to the fact that most recent publications make use of the digital object identifier (DOI)<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>, it is possible to use this index as the citation tag in our documents. By doing so, it is warranted that all citations reference to a unique document, different to usual tags on which an author could potentially have several publications for each year. This also open the window for further automatization, as there is reliable web services that offers the citation information of any given DOI, such as <a href>https://dx.doi.org/</a>.</p><p>This concept give birth to a new pandoc filter called <a href="https://github.com/aeroreyna/pandoc-doi2bib" target="_blank" rel="noopener">doi2bib</a>. This filter make use of specified bibliography file (only .bib) in the YAML configuration, it search for all references with the format @DOI:XXX.XXXand updates the this file accordingly. This means that any new reference is automatically added using the reliable information offered in the correct format by <em>doi.org</em>.</p><p>This tool offers the following benefits:</p><ul><li><p>The specified file can be an empty file, previously existed .bib filed or not existent.</p></li><li><p>Only newly references required to be downloaded, therefore it does not add significantly time of compilation.</p></li><li><p>Several document can share this .bib file, or use a global one for all your documents.</p></li><li><p>If all your reference uses this format, a new file with only the current citations in order of citation can be generated simply by changing the specified bibliography file in the document.</p></li></ul><p>To make use of this filter, just download the last build from the <a href="https://github.com/aeroreyna/pandoc-doi2bib" target="_blank" rel="noopener">Github</a> and paste it in the same Path of your pandoc executable. Then this can be implemented using the command <code>pandoc -s paper.md --filter pandoc-doi2bib --filter pandoc-citeproc -o paper.pdf</code></p><pre class="markdonw"><code>paper.md---title: Pandoc doi2bib filterbibliography: library.bibcsl: csl/apa.csl---The author of [@DOI:10.1007/s10462-018-09676-2] has mentioned this issue before.# Refereces:</code></pre><p>which results in:</p><p><img src="https://thepracticaldev.s3.amazonaws.com/i/otd6iy7ftb5dkr0sjdaj.png"></p><p>I´m using this framework for my thesis and prospect publications, so I hope it might helps others as well.</p><section class="footnotes" role="doc-endnotes"><hr><ol><li id="fn1" role="doc-endnote"><p>Others file types like bibtex, json, or yaml can be used as well.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>Digital object identifier (DOI) is a persistent identifier or handle used to identify objects uniquely, standardized by the International Organization for Standardization (ISO). <a href="https://en.wikipedia.org/wiki/Digital_object_identifier" target="_blank" rel="noopener">Wikipedia</a><a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      A new Pandoc filter to cite using DOI as reference tags.
    
    </summary>
    
    
      <category term="Markdown, Pandoc, Citation, DOI" scheme="http://yoursite.com/tags/Markdown-Pandoc-Citation-DOI/"/>
    
  </entry>
  
  <entry>
    <title>Writing Scientific Papers with Markdown in 2019</title>
    <link href="http://yoursite.com/2019/06/30/Writing-Scientific-Papers-with-Markdown-in-2019/"/>
    <id>http://yoursite.com/2019/06/30/Writing-Scientific-Papers-with-Markdown-in-2019/</id>
    <published>2019-06-30T21:49:04.000Z</published>
    <updated>2019-07-01T15:27:19.544Z</updated>
    
    <content type="html"><![CDATA[<p>Writing science is not a easy task. Furthermore of the complication of expressing highly complex ideas in a concise and clear fashion, it requires a proper framework that manages task like:</p><ul><li>References to previous work in the literature.</li><li>In-document references to equations, figures, tables, algorithms, sections, etc.</li><li>Proper formatting of the document and references, accordingly to the editorial.</li><li>Version Control to allow several authors to contribute and keep it organized, maintaining the full history between revisions and corrections.</li></ul><p>Markdown is a simple document structure with a easy learning curve, used in mostly for developers and present on almost all open source projects in nowadays. Its main benefit is that, differently from Latex or Html (also plain text documents), Markdown is easy to read directly from the source as it is, without any need of software interpretation.</p><p>Pandoc is a open source and powerful tool that cross-translate documents from several types of files. Given this tool, it is possible to write in plain text with any text editor the content of a scientific research work in Markdown, and to be transformed to Latex, PDF, or Docx documents, with the requirements specified for most published with ease. Pandoc make use of filters, which are executable files, that extends the capabilities of Markdown, and give this framework robustness to accomplish the scientific writing needs.</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Writing science is not a easy task. Furthermore of the complication of expressing highly complex ideas in a concise and clear fashion, it requires a proper framework that manages task like:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;References to previous work in the literature.&lt;/li&gt;
&lt;li&gt;In-document references to equations, figures, tables, algorithms, sections, etc.&lt;/li&gt;
&lt;li&gt;Proper formatting of the document and references, accordingly to the editorial.&lt;/li&gt;
&lt;li&gt;Version Control to allow several authors to contribute and keep it organized, maintaining the full history between revisions and corrections.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Markdown is a simple document structure with a easy learning curve, used in mostly for developers and present on almost all open source projects in nowadays. Its main benefit is that, differently from Latex or Html (also plain text documents), Markdown is easy to read directly from the source as it is, without any need of software interpretation.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Efficient Ultra-Dense Network Capacity Simulations</title>
    <link href="http://yoursite.com/2019/06/28/Efficient-Network-Capacity-Simulations/"/>
    <id>http://yoursite.com/2019/06/28/Efficient-Network-Capacity-Simulations/</id>
    <published>2019-06-28T13:27:14.000Z</published>
    <updated>2019-07-01T20:34:09.206Z</updated>
    
    <content type="html"><![CDATA[<h1 id="introduction">Introduction</h1><p>The computation of the network capacity requires the calculation of each link between cells (<span class="math inline">\(Q\)</span>) and users (<span class="math inline">\(U\)</span>) over the channels (<span class="math inline">\(N\)</span>), determined by the Channel Allocation (CA) matrix <span class="math inline">\(X_{Q,U,N}\)</span>, considering the allocated power <span class="math inline">\(P_{Q,N}\)</span> over each channel. This function is non-linear due to the calculation of interference, as can be observed in the SNIR (Eq. 1), which represent the sum of all the received signals produced by cells sharing the channel.</p><p><span id="eq:NetworkCapacity"><span class="math display">\[C^{Network}(X_{Q,U,N}, P_{Q,N}) = \sum_{q=1}^Q{  \sum_{u=1}^{U}{    \sum_{n=1}^{N}{      \frac{B}{N}log_2(1 + \underbrace{        \frac{          X_{q,u,n} \overbrace{P_{q,n} H(q,u,n)}^\text{DessiredSingal}        }{N_0 + I(q,u,n)}      }_\text{SNIR})    }  }}\qquad(1)\]</span></span></p><p>A straight forward strategy could be coded as:</p><div id="lst:alg1" class="listing matlab"><p>Listing 1: Straight forward calculation of the capacity of the network.</p><div class="sourceCode" id="cb1"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb1-1"><a href="#cb1-1"></a>C = zeros(U,<span class="fl">1</span>);</span><span id="cb1-2"><a href="#cb1-2"></a>for q=<span class="fl">1</span>:Q</span><span id="cb1-3"><a href="#cb1-3"></a>  for u=<span class="fl">1</span>:U</span><span id="cb1-4"><a href="#cb1-4"></a>    for n=<span class="fl">1</span>:N</span><span id="cb1-5"><a href="#cb1-5"></a>      if(X(q,u,n)) <span class="co">%if is allocated</span></span><span id="cb1-6"><a href="#cb1-6"></a>        DessiredSingal = P(q,n) * H(q,u,n);</span><span id="cb1-7"><a href="#cb1-7"></a>        Interferece = <span class="fl">0</span>;</span><span id="cb1-8"><a href="#cb1-8"></a>        for q2=<span class="fl">1</span>:Q</span><span id="cb1-9"><a href="#cb1-9"></a>          for u2=<span class="fl">1</span>:U</span><span id="cb1-10"><a href="#cb1-10"></a>            if(X(q2,u2,n))</span><span id="cb1-11"><a href="#cb1-11"></a>              Interferece = Interferece + P(q2,n) * H(q2,u2,n);</span><span id="cb1-12"><a href="#cb1-12"></a>            end</span><span id="cb1-13"><a href="#cb1-13"></a>          end</span><span id="cb1-14"><a href="#cb1-14"></a>        end</span><span id="cb1-15"><a href="#cb1-15"></a>        <span class="co">% add to the user capacity</span></span><span id="cb1-16"><a href="#cb1-16"></a>        C(u) = C(u) + B/N *...</span><span id="cb1-17"><a href="#cb1-17"></a>               log2(<span class="fl">1</span> + DessiredSingal / (Noise + Interferece));</span><span id="cb1-18"><a href="#cb1-18"></a>      end</span><span id="cb1-19"><a href="#cb1-19"></a>    end</span><span id="cb1-20"><a href="#cb1-20"></a>  end</span><span id="cb1-21"><a href="#cb1-21"></a>end</span></code></pre></div></div><p>The procedure in Alg. 1 has a complexity of <span class="math inline">\(\mathcal{O}(Q^2U^2N * \mathcal{O}(H(q,u,n)))\)</span><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> received power calculations in the worst scenario, <span class="math inline">\(X(q,u,n)=1 \;\forall\; q,u,n\)</span>. However, this worst scenario is unrealistic as users are usually attended only by a single cell, and each cell can use once each channel between its users at any time. Therefore, worst case is represent by those allocations on which the cells make use of all channels among their users (Reuse 1), resulting on <span class="math inline">\(\mathcal{O}(Q^2N*\mathcal{O}(P_{q,n} * H(q,u,n)))\)</span>. Such allocations are usually used on works that evaluated the performance of Ultra-Dense Networks (UDNs), such as <span class="citation" data-cites="DOI:10.1109/jsac.2017.2687638">Nguyen and Kountouris (<a href="#ref-DOI:10.1109/jsac.2017.2687638" role="doc-biblioref">2017</a>)</span> and <span class="citation" data-cites="DOI:10.1109/camad.2015.7390494">Romanous et al. (<a href="#ref-DOI:10.1109/camad.2015.7390494" role="doc-biblioref">2015</a>)</span>. This means that the evaluation of the network complicates with the network densification exponentially, increasing the delay of solving RA. Also the complexity of calculating the channel gain <span class="math inline">\(H(q,u,n)\)</span> depends on the channel model, which requires a square root calculation for the Path Loss and generating one or several random number for Shadowing and Multi-Trajectory Losses. For this reason, it is necessary to implement efficient methods for this calculations.</p><p>In this case is convenient to pre-calculate the channel gains <span class="math inline">\(H_{q,u,n} = H(q,u,n)\)</span>. This is due to the calculation of a square root requires several basic operations, these gains can be considered fixed over the time on which RA is executed [REFs] and the worst case scenario is highly probable in most implementations of RA algorithms over UDNs. The distance between cells and users (<span class="math inline">\(D_{q,u}\)</span>) is performed and multiplied by the channel random gains of each channel, . As <span class="math inline">\(H_{q,u,n}\)</span> remains fix through the RA process, this is calculated only once and reused over all the rest allocation evaluations, thus the <span class="math inline">\(\mathcal{O}(QU*\mathcal{O}(\sqrt{D_{q,n}}) + UN)\)</span> complexity of this calculation is removed. Given <span class="math inline">\(H_{q,u,n}\)</span>, it is possible to calculate the user signal perceived from all cells as <span class="math inline">\(S_{q,u,n} = P_{q,n} * H_{q,u,n}\)</span>. Consequently, the remained complexity is <span class="math inline">\(\mathcal{O}(Q^2N + QN)\)</span> which represent the complexity of CA and PA respectively.</p><p>One significant improvement for the computer efficiency can be obtained by the vectorization<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> of Alg. 1 as MATLAB® is optimized for operations involving matrices and vectors (similarly to other Programming Languages like Python with Numpy), and it allows the use of parallel GPU computations easily. Making this change in implementation do not affect the calculation computer complexity, but it positively affects the execution time due to the compilation optimizations of the software.</p><div id="lst:alg2" class="listing matlab"><p>Listing 2: Vectorized calculation of the capacity of the network.</p><div class="sourceCode" id="cb2"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb2-1"><a href="#cb2-1"></a>C = zeros(U, <span class="fl">1</span>);</span><span id="cb2-2"><a href="#cb2-2"></a>for n=<span class="fl">1</span>:N</span><span id="cb2-3"><a href="#cb2-3"></a>  usersInx = X(:,n) ~= <span class="fl">1</span>; <span class="co">%list of users using channel n</span></span><span id="cb2-4"><a href="#cb2-4"></a>  cellsInx = A(usersInx); <span class="co">%cells attending these users</span></span><span id="cb2-5"><a href="#cb2-5"></a>  signalsRx      = S(cellsInx, usersInx, n); <span class="co">%max size of QxQ</span></span><span id="cb2-6"><a href="#cb2-6"></a>  DessiredSingal = signalsRx * eye(size(signalsRx)); <span class="co">%Diagonal</span></span><span id="cb2-7"><a href="#cb2-7"></a>  Interference   = sum(signalsRx, <span class="fl">2</span>) - DessiredSingal;</span><span id="cb2-8"><a href="#cb2-8"></a>  C(usersInx)    = C(usersInx) + B/N *...</span><span id="cb2-9"><a href="#cb2-9"></a>                   log2(<span class="fl">1</span> + dessiredS / (Noise + Interference));</span><span id="cb2-10"><a href="#cb2-10"></a>end</span></code></pre></div></div><p>To simplify this implementation the Channel Allocation matrix is divided on a smaller channel allocation between users and channels <span class="math inline">\(X_{u,n}\)</span>, and a separated variable <span class="math inline">\(A_u\)</span> contains the cell associated to each user. This setup is usually used due to association is performed in a separated pre-processing before RA, if required. Then, as shown in Algorithm 2 a square matrix of received signal between the users and cells sharing the channel can be obtained. The diagonal of the <span class="math inline">\(signalsRx\)</span> matrix represent the desired signals and the rest determined the interference perceived. Further vectorization can be implemented, to calculate the capacity or all the channels, but this requires complicated highly dimensional matrix transformations and memory space, which limits its implementation as shown in Appendix #.</p><h1 id="block-allocation-proposal">Block Allocation Proposal</h1><p>The proposed block allocation of this work [SELF_REF] allows to further reduce the complexity of the evaluation of the network capacity. The proposal considers CA y PA as two consecutive sub-problems to solve RA, which is well-known strategy in these works [REFs]. To solve CA, the power of each cell is allocated flat over the channels, i.e., <span class="math inline">\(P(q,n) = P_q/N \;\forall\; q, n\)</span>. This simplification added to the use of Path Loss as the only fading factor in the channel model make it is possible to storage the perceived signal of the users from all cells as <span class="math inline">\(S_{q,u} = P_q/N * H_{q,u,n}\)</span>.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Therefore, the PA part of the complexity is eliminated resulting in <span class="math inline">\(\mathcal{O}(Q^2N)\)</span>.</p><p>Furthermore, the exclusive use of Path Loss in the channel model, considers a flat behavior of the channels gains. This means that the same capacity is achieved over any channel with an identical configuration of users sharing it, which incentives to recollect all possible configurations capacities. However, this strategy is unpractical as it requires <span class="math inline">\(2^U\)</span> computations and space in memory. Nevertheless, due to the block allocation scheme proposed in this work, it is highly probable that multiple adjacent channels are share by the same configuration of users. Therefore, the last configuration of channels and capacity can be recorded, to compare with the consecutive channels and skip those calculations, which lead to the worst case complexity <span class="math inline">\(\mathcal{O}(Q^2log(N))\)</span>. This implementation is exposed in Algorithm 3 and used for the network simulations on this work.</p><div id="lst:alg3" class="listing matlab"><p>Listing 3: Vectorized calculation of the capacity of the network.</p><div class="sourceCode" id="cb3"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb3-1"><a href="#cb3-1"></a>C = zeros(U,<span class="fl">1</span>);</span><span id="cb3-2"><a href="#cb3-2"></a>lastUI = [];</span><span id="cb3-3"><a href="#cb3-3"></a>lastUC = [];</span><span id="cb3-4"><a href="#cb3-4"></a>for n=<span class="fl">1</span>:N</span><span id="cb3-5"><a href="#cb3-5"></a>  usersInx = X(:,n) ~= <span class="fl">1</span>; <span class="co">%list of users using channel n</span></span><span id="cb3-6"><a href="#cb3-6"></a>  if(n &gt; <span class="fl">1</span> &amp;&amp; all(lastUI==usersInx))</span><span id="cb3-7"><a href="#cb3-7"></a>    tempC = lastUC;</span><span id="cb3-8"><a href="#cb3-8"></a>  else</span><span id="cb3-9"><a href="#cb3-9"></a>    cellsInx = A(usersInx); <span class="co">%cells attending these users</span></span><span id="cb3-10"><a href="#cb3-10"></a>    signalsRx = S(cellsInx, usersInx); <span class="co">%max size of QxQ</span></span><span id="cb3-11"><a href="#cb3-11"></a>    DessiredSingal = signalsRx * eye(size(signalsRx)); <span class="co">%Diagonal</span></span><span id="cb3-12"><a href="#cb3-12"></a>    Interference   = sum(signalsRx, <span class="fl">2</span>) - DessiredSingal;</span><span id="cb3-13"><a href="#cb3-13"></a>    tempC = B/N *log2(<span class="fl">1</span> + dessiredS / (Noise + Interference));</span><span id="cb3-14"><a href="#cb3-14"></a>  end</span><span id="cb3-15"><a href="#cb3-15"></a>  C(usersInx) = C(usersInx) + tempC</span><span id="cb3-16"><a href="#cb3-16"></a>  usersInx = usersInx;</span><span id="cb3-17"><a href="#cb3-17"></a>  lastUC = tempC;</span><span id="cb3-18"><a href="#cb3-18"></a>end</span></code></pre></div></div><div id="refs" class="references" role="doc-bibliography"><div id="ref-DOI:10.1109/jsac.2017.2687638"><p>Nguyen, Van Minh, and Marios Kountouris. 2017. “Performance Limits of Network Densification.” <em>IEEE Journal on Selected Areas in Communications</em> 35 (6). Institute of Electrical; Electronics Engineers (IEEE): 1294–1308. <a href="https://doi.org/10.1109/jsac.2017.2687638" target="_blank" rel="noopener">https://doi.org/10.1109/jsac.2017.2687638</a>.</p></div><div id="ref-DOI:10.1109/camad.2015.7390494"><p>Romanous, Bashar, Naim Bitar, Ali Imran, and Hazem Refai. 2015. “Network Densification: Challenges and Opportunities in Enabling 5G.” In <em>2015 IEEE 20th International Workshop on Computer Aided Modelling and Design of Communication Links and Networks (CAMAD)</em>. IEEE. <a href="https://doi.org/10.1109/camad.2015.7390494" target="_blank" rel="noopener">https://doi.org/10.1109/camad.2015.7390494</a>.</p></div></div><section class="footnotes" role="doc-endnotes"><hr><ol><li id="fn1" role="doc-endnote"><p>This complexity refers to the evaluation of network capacity, not the complexity of solving RA.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn2" role="doc-endnote"><p>The process of revising loop-based, scalar-oriented code to use MATLAB matrix and vector operations is called vectorization. Vectorizing your code is worthwhile for several reasons: Appearance, Less Error Prone and Performance <a href>https://www.mathworks.com/help/matlab/matlab_prog/vectorization.html</a>.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li><li id="fn3" role="doc-endnote"><p>This calculation is performed to associated users with the cell that offers the highest SNR using the Path Loss Association. So these results can be carried from such stage.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;The computation of the network capacity requires the calculation of each link between cells (&lt;span class=&quot;math inline&quot;&gt;\(Q\)&lt;/span&gt;) and users (&lt;span class=&quot;math inline&quot;&gt;\(U\)&lt;/span&gt;) over the channels (&lt;span class=&quot;math inline&quot;&gt;\(N\)&lt;/span&gt;), determined by the Channel Allocation (CA) matrix &lt;span class=&quot;math inline&quot;&gt;\(X_{Q,U,N}\)&lt;/span&gt;, considering the allocated power &lt;span class=&quot;math inline&quot;&gt;\(P_{Q,N}\)&lt;/span&gt; over each channel. This function is non-linear due to the calculation of interference, as can be observed in the SNIR (Eq. 1), which represent the sum of all the received signals produced by cells sharing the channel.&lt;/p&gt;
&lt;p&gt;&lt;span id=&quot;eq:NetworkCapacity&quot;&gt;&lt;span class=&quot;math display&quot;&gt;\[
C^{Network}(X_{Q,U,N}, P_{Q,N}) = \sum_{q=1}^Q{
  \sum_{u=1}^{U}{
    \sum_{n=1}^{N}{
      \frac{B}{N}log_2(1 + \underbrace{
        \frac{
          X_{q,u,n} \overbrace{P_{q,n} H(q,u,n)}^\text{DessiredSingal}
        }{N_0 + I(q,u,n)}
      }_\text{SNIR})
    }
  }
}
\qquad(1)\]&lt;/span&gt;&lt;/span&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Algorithmic Trading with Matlab</title>
    <link href="http://yoursite.com/2019/06/20/Algorithmic-Trading-with-Matlab/"/>
    <id>http://yoursite.com/2019/06/20/Algorithmic-Trading-with-Matlab/</id>
    <published>2019-06-21T04:59:00.000Z</published>
    <updated>2019-06-28T13:54:37.390Z</updated>
    
    <content type="html"><![CDATA[<h3 id="getting-started-with-algorithmic-trading-in-matlab.">Getting started with Algorithmic Trading in Matlab.</h3><p>In Algorithmic Trading, a strategy is formed using one or several technical analysis indicators with the objective of provide an efficient and automatized trading framework that maximized the revenue, along other factors like Sharpe Ratio and minimize the Maximum Drawdown.</p><p>Investopedia give us the follow definition of Technical Analysis:</p><blockquote><p>Technical analysis is a trading discipline employed to evaluate investments and identify trading opportunities by analyzing statistical trends gathered from trading activity, such as price movement and volume. Unlike fundamental analysts, who attempt to evaluate a security's intrinsic value, technical analysts focus on patterns of price movements, trading signals and various other analytical charting tools to evaluate a security's strength or weakness.</p><p><a href="https://www.investopedia.com/terms/t/technicalanalysis.asp" target="_blank" rel="noopener">Investopedia</a></p></blockquote><p>The main idea behind these techniques is that price action itself contains all the information required about the state of the asset, and certain patterns observed in the history of it, or other general patters among the history of certain assets, might repeat. Therefore, if a trading strategy results efficient with historical data, chances are that this might works as well with current price action.</p><p>Cryptocurrencies are digital asset designed to work as a medium of exchange that uses strong cryptography to secure financial transactions. These use decentralized control that works through distributed ledger technology, typically a blockchain, serving as a public financial transaction database. <a href="https://en.wikipedia.org/wiki/Cryptocurrency" target="_blank" rel="noopener">More on Wikipedia</a>. Bitcoin, is considered the first decentralized cryptocurrency and the most popular and liquid of them. Several online services, like <a href="https://www.binance.com/?ref=11205707" target="_blank" rel="noopener">Binance</a>, <a href="https://bitfinex.com" target="_blank" rel="noopener">Bitfinex</a>, allows trading over these instruments, against the American dollar (USD) or Bitcoin (BTC), with a minimum entry amount of 50 USD when buying with credit card.</p><p>In this work, we´ll make use of Matlab to elaborate the algorithm and the public <a href="https://api.bitfinex.com/v2/" target="_blank" rel="noopener">Bitfinex Api</a> to acquire the historical price of several pairs of cryptocurrencies. Matlab offers a great deal of toolboxes for different areas of research, like the <a href="https://www.mathworks.com/products/finance.html" target="_blank" rel="noopener">Financial Toolbox</a>, which give us technical indicators and charting capabilities right out of the box for this proposes.</p><p>Although Matlab offers a very comprehensive documentation, examples of algorithmic trading are scare, and their application on cryptocurrencies could be of interest of new comers in this area.</p><p>The first step is to acquire the price action information of the last 1000 days of BTC against USD, to do so Matlab offers the function <em>webread</em> that read content from RESTful web services.</p><div class="sourceCode" id="cb1"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb1-1"><a href="#cb1-1"></a>symbol = <span class="st">&#39;BTCUSD&#39;</span></span><span id="cb1-2"><a href="#cb1-2"></a>urlTemp = sprintf(<span class="st">&#39;https://api.bitfinex.com/v2/candles/trade:1D:t%s/hist&#39;</span>, Symbol);</span><span id="cb1-3"><a href="#cb1-3"></a>data = webread(urlTemp, <span class="st">&#39;limit&#39;</span>, <span class="fl">1000</span>, <span class="st">&#39;sort&#39;</span>, -<span class="fl">1</span>);</span></code></pre></div><p>The response storage in <em>data</em> contains a matrix of 6 columns and 1000 days, with the information of the date; low, high, open and close price of such day and amount of volume trade over it. This information is more useful in a timetable object, which allows a more handy way of manipulating the data, like sorting using the Time column.</p><div class="sourceCode" id="cb2"><pre class="sourceCode matlab"><code class="sourceCode matlab"><span id="cb2-1"><a href="#cb2-1"></a>date = datetime(datestr(data(:,<span class="fl">1</span>)/<span class="fl">86400</span>/<span class="fl">1000</span> + datenum(<span class="fl">1970</span>,<span class="fl">1</span>,<span class="fl">1</span>)));</span><span id="cb2-2"><a href="#cb2-2"></a>open = data(:,<span class="fl">2</span>);</span><span id="cb2-3"><a href="#cb2-3"></a>close = data(:,<span class="fl">3</span>);</span><span id="cb2-4"><a href="#cb2-4"></a>high = data(:,<span class="fl">4</span>);</span><span id="cb2-5"><a href="#cb2-5"></a>low = data(:,<span class="fl">5</span>);</span><span id="cb2-6"><a href="#cb2-6"></a>vol = data(:,<span class="fl">6</span>);</span><span id="cb2-7"><a href="#cb2-7"></a>tt = timetable(datetime(date), open, high, low, close, vol);</span><span id="cb2-8"><a href="#cb2-8"></a>btc = sortrows(tt, <span class="st">&#39;Time&#39;</span>);</span></code></pre></div>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;getting-started-with-algorithmic-trading-in-matlab.&quot;&gt;Getting started with Algorithmic Trading in Matlab.&lt;/h3&gt;
&lt;p&gt;In Algorithmic Trading, a strategy is formed using one or several technical analysis indicators with the objective of provide an efficient and automatized trading framework that maximized the revenue, along other factors like Sharpe Ratio and minimize the Maximum Drawdown.&lt;/p&gt;
&lt;p&gt;Investopedia give us the follow definition of Technical Analysis:&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
